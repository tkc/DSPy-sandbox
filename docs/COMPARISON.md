# DSPy と類似ライブラリの比較

このドキュメントは、DSPy と近い用途のライブラリを**用途別・設計思想別**に整理した比較です。  
細部の実装差よりも「何が得意か／何に向いているか」に焦点を当てています。

## 早見表

| 観点 | DSPy | LangChain | LlamaIndex | Haystack | Semantic Kernel | Guidance | PydanticAI |
|---|---|---|---|---|---|---|---|
| 中心思想 | **宣言的にAIプログラムを設計** | **チェーン/エージェント構築** | **RAG/インデックス中心** | **検索/RAGパイプライン** | **プラグイン/オーケストレーション** | **制約付き生成** | **型安全なエージェント** |
| 強み | 最適化器で自動改善、構造化設計 | 統合数が多い、実例が豊富 | RAG特化、データ接続が豊富 | 検索・評価・パイプラインが強い | 企業システム統合に強い | 厳格フォーマット出力 | 型/スキーマで堅牢 |
| 弱み | 学習コスト、思想が独特 | 抽象が多く複雑化しやすい | 汎用エージェントは弱め | 設定がやや重い | Python中心だと遠い | 周辺エコシステム少なめ | 低レベル制御が少ない |
| 典型用途 | 最適化が必要なAIシステム | まず動くアプリを早く作る | 検索/RAGアプリ | エンタープライズRAG | 企業統合/C#/.NET | 形式厳格な生成 | 厳密な出力仕様 |

## ざっくり選定ガイド

- **DSPy**: プロンプトの自動改善や最適化を含む “AIプログラム設計” を重視する場合。
- **LangChain**: とにかく早く動くプロトタイプを作りたい場合。
- **LlamaIndex / Haystack**: RAG（検索＋生成）中心のアプリを作る場合。
- **Semantic Kernel**: 企業基盤やC#/.NETを中心に統合したい場合。
- **Guidance / PydanticAI**: 出力形式や型の厳密さが重要な場合。

## 用途別の向き不向き

### 1) RAG中心のアプリ
- **強い**: LlamaIndex, Haystack
- **補完的**: LangChain（ツール連携）
- **DSPy**: RAG最適化をやりたい場合に強い

### 2) エージェント系アプリ
- **強い**: LangChain, Semantic Kernel
- **DSPy**: モジュール化・最適化を重視する場合
- **Guidance/PydanticAI**: 出力制約が強いタスク

### 3) 最適化や評価が重要
- **強い**: DSPy
- **補完的**: Haystack（評価パイプライン）

### 4) 企業統合・運用
- **強い**: Semantic Kernel, Haystack
- **DSPy**: 研究・プロトタイプで高い改善効果を狙う場合

## Agentic RAG とは

Agentic RAG は、RAG（検索＋生成）に**エージェント的な意思決定ループ**を組み合わせた方式です。  
単発の「検索 → 生成」ではなく、**「計画 → 検索 → 観察 → 再計画」**を繰り返して、
必要に応じて複数回の検索やツール利用を行い、回答精度を高めます。

### 特徴

- 質問を分解して段階的に検索する
- 中間結果を見て再検索・再推論する
- ツール（検索/計算/DB/API など）を状況に応じて選択する

### 向いている用途

- マルチホップ QA（複数ソースをまたぐ質問）
- 不確実性が高い調査タスク
- 最新情報の追跡や継続的な探索が必要なタスク

## Agentic RAG のアーキテクチャ（詳解）

Agentic RAG は、**RAG パイプラインにエージェントの制御ループ**を重ねた構成です。  
典型的には次のコンポーネントで構成されます。

### 1) プランナー（Planner）
- ユーザーの質問を分析し、**サブタスクや検索方針**を決める。
- 例: 「まず定義を調べる → 次に比較表を取得する → 最後にまとめる」

### 2) リトリーバー（Retriever）
- ベクトル検索、BM25、ハイブリッド検索などで **関連ドキュメントを取得**する。
- 取得結果のスコアリングやフィルタリングを行う。

### 3) ツール実行層（Tools）
- 検索以外のツール（DB、API、計算、ブラウザ、コード実行）を利用可能。
- エージェントが **必要に応じてツールを選択**する。

### 4) 読解・統合（Reader / Synthesizer）
- 取得した文書を読み取り、**根拠を統合して回答**を生成する。
- ここで引用や根拠の明示を入れる場合が多い。

### 5) 監督・評価（Critic / Evaluator）
- 生成結果を検証し、**不足や矛盾を検出**する。
- 必要なら「再検索 → 再生成」へ戻る。

---

### 典型フロー（ループ構造）

1. **Plan**: 何を調べるべきかを決める
2. **Retrieve**: 必要な情報を検索
3. **Read**: 文書を要約・統合
4. **Critique**: 不足や矛盾を検出
5. **Re-plan**: 追加検索や別手段を決定

このループにより、単発の RAG よりも **頑健性と精度**が向上します。

---

### 実運用での注意点

- **コスト増**: ループ回数分だけ API コストが増える
- **遅延増**: 逐次処理でレイテンシが伸びる
- **評価設計が重要**: 何を「良い回答」とするかの指標が必要

---

### まとめ

Agentic RAG は、
**「検索＋生成」から「計画＋探索＋統合＋検証」へ拡張したアーキテクチャ**です。  
複雑な質問や調査系タスクで特に効果が高く、DSPy でもこのようなループ構成を組めます。

## まとめ

- **DSPy** は「宣言的設計＋最適化」の思想が中心。
- **LangChain** は「統合・プロトタイピングの速さ」。
- **LlamaIndex / Haystack** は「RAG特化」。
- **Semantic Kernel** は「企業統合」。
- **Guidance / PydanticAI** は「出力厳密性」。

用途に合わせて使い分けると、実装コストと成果のバランスが取りやすいです。
